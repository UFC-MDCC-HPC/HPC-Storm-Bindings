<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000174170214ec8de902f58c9e2758714817ff949c0c098fc0bb0d7f68cfab78767e1a0c1983242dfd742d7e3732d9050312c8c95d9130a7071b3ccddfe9b59fd7b8df6676b7b12a4a3f7e1fdad77bdaeb4396d673feddeaf3545c105ba8114bc03f067758555bf72db629d435bfeae77bbb9a77a0690d7415de49fea886da17dd1" isAbstract="true" kind="Binding" name="Binding" packagePath="br.ufc.mdcc.hpc.storm.binding.channel">
    <baseType>
      <extensionType>
        <extends>true</extends>
      </extensionType>
      <component hash_component_UID="002400000480000094000000060200000024000052534131000400001100000027a317f913743facf128cbff4267868d0182882c7a41b97f60fb74e4064eb9d913c120c2036c58f445bfa59bc83791105ba6615e96c8338454e80fca5da50166bb0231effb46ba9f76de1f7a2bab11e256939eec39563e7c748f35cab54fba13eec406fc39d6ceee356d655cd83d85a4b258c273deea8b2a01f3fa705d588290" localRef="base" location="br.ufc.mdcc.hpc.storm.kind.Binding/Binding.hpe" name="Binding" package="br.ufc.mdcc.hpc.storm.kind" version="1.0.0.0">
        <visualDescription h="95" w="95" x="254" y="228">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <unitBounds parallel="false" uRef="root">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
        <unitBounds parallel="true" uRef="peer">
          <visualDescription h="20" w="20" x="28" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
  </header>
  <componentInfo>
    <interface iRef="IChannelRoot" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* AUTOMATICALLY GENERATE CODE */&#xA;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface BaseIChannelRoot : BaseIRoot, IBindingKind &#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIChannelRoot.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/BaseIRoot.dll</dependency>
        </file>
        <file contents="using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface IChannelRoot : BaseIChannelRoot, IRoot&#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="IChannelRoot.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannelRoot.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/IRoot.dll</dependency>
        </file>
        <file contents="using System;&#xA;using MPI;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Collections.Generic;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;/*&#xA;&#x9;public enum AliencommunicatorOperation {&#xA;&#x9;&#x9;SEND, &#xA;&#x9;&#x9;RECEIVE, &#xA;&#x9;&#x9;SEND_ARRAY,&#xA;&#x9;&#x9;RECEIVE_ARRAY,&#xA;&#x9;&#x9;PROBE,&#xA;&#x9;&#x9;ALL_GATHER,&#xA;&#x9;&#x9;ALL_GATHER_FLATTENED,&#xA;&#x9;&#x9;ALL_REDUCE,&#xA;&#x9;&#x9;ALL_REDUCE_ARRAY,&#xA;&#x9;&#x9;ALL_TO_ALL,&#xA;&#x9;&#x9;ALL_TO_ALL_FLATTENED,&#xA;&#x9;&#x9;REDUCE_SCATTER,&#xA;&#x9;&#x9;BROADCAST,&#xA;&#x9;&#x9;BROADCAST_ARRAY,&#xA;&#x9;&#x9;SCATTER,&#xA;&#x9;&#x9;SCATTER_FROM_FLATTENED,&#xA;&#x9;&#x9;GATHER,&#xA;&#x9;&#x9;GATHER_FLATTENED,&#xA;&#x9;&#x9;REDUCE,&#xA;&#x9;&#x9;REDUCE_ARRAY&#xA;&#x9;};&#xA;&#x9;*/&#xA;&#xA;&#x9;public class AliencommunicatorOperation {&#xA;&#x9;&#x9;public const int SEND = 0; &#xA;&#x9;&#x9;public const int RECEIVE = 1;&#xA;&#x9;&#x9;public const int SEND_ARRAY = 2;&#xA;&#x9;&#x9;public const int RECEIVE_ARRAY = 3;&#xA;&#x9;&#x9;public const int PROBE = 4;&#xA;&#x9;&#x9;public const int ALL_GATHER = 5;&#xA;&#x9;&#x9;public const int ALL_GATHER_FLATTENED= 6;&#xA;&#x9;&#x9;public const int ALL_REDUCE = 7;&#xA;&#x9;&#x9;public const int ALL_REDUCE_ARRAY = 8;&#xA;&#x9;&#x9;public const int ALL_TO_ALL = 9;&#xA;&#x9;&#x9;public const int ALL_TO_ALL_FLATTENED = 10;&#xA;&#x9;&#x9;public const int REDUCE_SCATTER = 11;&#xA;&#x9;&#x9;public const int BROADCAST = 12;&#xA;&#x9;&#x9;public const int BROADCAST_ARRAY = 13;&#xA;&#x9;&#x9;public const int SCATTER = 14;&#xA;&#x9;&#x9;public const int SCATTER_FROM_FLATTENED = 15;&#xA;&#x9;&#x9;public const int GATHER = 16;&#xA;&#x9;&#x9;public const int GATHER_FLATTENED = 17;&#xA;&#x9;&#x9;public const int REDUCE = 18;&#xA;&#x9;&#x9;public const int REDUCE_ARRAY = 19;&#xA;&#x9;};&#xA;&#xA;&#x9;public interface Aliencommunicator&#xA;&#x9;{&#xA;&#x9;&#x9;#region point-to-point operations&#xA;&#xA;&#x9;&#x9;// Value versions ...&#xA;&#xA;&#x9;&#x9;void Send&lt;T> (T value, Tuple&lt;int,int> dest, int tag);&#xA;&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int tag, out T outValue); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;T Receive&lt;T> (Tuple&lt;int,int> source, int tag); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int,int> source, int tag, out T value); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;Request ImmediateSend&lt;T> (T value, Tuple&lt;int,int> dest, int tag);&#xA;&#x9;&#x9;ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;// Array versions ... &#xA;&#x9;&#x9;void Send&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag);&#xA;&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;Request ImmediateSend&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag);&#xA;&#x9;&#x9;ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag, T[] values);&#xA;&#xA;&#x9;&#x9;// Probe.&#xA;&#xA;&#x9;&#x9;Status Probe (Tuple&lt;int,int> source, int tag);&#xA;&#x9;&#x9;Status ImmediateProbe (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T>(T[] inValues, int dest, int tag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T>(T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;#endregion point-to-point operations&#xA;&#xA;&#x9;&#x9;#region collective operations&#xA;&#xA;&#x9;&#x9;#region AllToAll&#xA;&#xA;&#x9;&#x9;T[] Allgather&lt;T> (int facet, T value);&#xA;&#x9;&#x9;void Allgather&lt;T> (int facet, T inValue, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void AllgatherFlattened&lt;T> (int facet, T[] inValues, int count, ref T[] outValues);&#xA;&#x9;&#x9;void AllgatherFlattened&lt;T> (int facet, T[] inValues, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T Allreduce&lt;T>(int facet, T value, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;T[] Allreduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;void Allreduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T[] Alltoall&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;void Alltoall&lt;T> (int facet, T[] inValues, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void AlltoallFlattened&lt;T> (int facet, T[] inValues, int[] sendCounts, int[] recvCounts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T[] ReduceScatter&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int[] counts);&#xA;&#x9;&#x9;void ReduceScatter&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region OneToAll&#xA;&#xA;&#x9;&#x9;void Broadcast&lt;T> (int facet, ref T value, int root);&#xA;&#x9;&#x9;void Broadcast&lt;T> (int facet, ref T[] values, int root);&#xA;&#xA;&#x9;&#x9;void Scatter&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;T Scatter&lt;T>(int facet, int root);&#xA;&#x9;&#x9;void Scatter&lt;T>(int facet);&#xA;&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, int[] counts, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion OneToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region AllToOne&#xA;&#xA;&#x9;&#x9;T[] Gather&lt;T> (int facet, T value, int root);&#xA;&#x9;&#x9;T[] Gather&lt;T> (int facet, int root);&#xA;&#x9;&#x9;void Gather&lt;T>(int facet);&#xA;&#x9;&#x9;void Gather&lt;T>(int facet, T inValue, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void GatherFlattened&lt;T>(int facet, int count, ref T[] outValues);&#xA;&#x9;&#x9;T[] GatherFlattened&lt;T>(int facet, int count);&#xA;&#x9;&#x9;void GatherFlattened&lt;T> (int facet, T[] inValues, int root);&#xA;&#x9;&#x9;void GatherFlattened&lt;T>(int facet);&#xA;&#x9;&#x9;void GatherFlattened&lt;T> (int facet, int[] counts, ref T[] outValues);&#xA;&#x9;&#x9;T[] GatherFlattened&lt;T>(int facet, int[] counts);&#xA;&#xA;&#x9;&#x9;T Reduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;T[] Reduce&lt;T>(int facet, T[] values, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;void Reduce&lt;T>(int facet, T[] inValues, ReductionOperation&lt;T> op, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToOne&#xA;&#xA;&#xA;&#x9;&#x9;#endregion collective operations&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public class Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Status internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal Status(MPI.Status internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int,int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int,int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count(type);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Cancelled;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class CompletedStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.CompletedStatus internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal CompletedStatus(MPI.CompletedStatus internal_status, Tuple&lt;int,int> source) : base(internal_status, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(MPI.CompletedStatus internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new CompletedStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking communication request.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// Each request object refers to a single&#xA;&#x9;/// communication operation, such as non-blocking send &#xA;&#x9;/// (see &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>)&#xA;&#x9;/// or receive. Non-blocking operations may progress in the background, and can complete&#xA;&#x9;/// without any user intervention. However, it is crucial that outstanding communication&#xA;&#x9;/// requests be completed with a successful call to &lt;see cref=&quot;Wait&quot;/> or &lt;see cref=&quot;Test&quot;/>&#xA;&#x9;/// before the request object is lost.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class Request&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Request internal_request;&#xA;&#x9;&#x9;private Tuple&lt;int,int> source;&#xA;&#xA;&#x9;&#x9;internal Request(MPI.Request internal_request, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Wait ();&#xA;&#x9;&#x9;&#x9;return CompletedStatus.createStatus (internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Test ();&#xA;&#x9;&#x9;&#x9;return internal_status != null ? CompletedStatus.createStatus (internal_status, source) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;internal_request.Cancel ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static Request createRequest(MPI.Request internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new Request(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public abstract class ReceiveRequest : Request&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;internal ReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue ();&#xA;    }&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ValueReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#xA;&#x9;&#x9;internal ValueReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[]) this.internal_request.GetValue ();&#xA;&#x9;&#x9;&#x9;return (T) ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static ValueReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ValueReceiveRequest&lt;T>(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ArrayReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#xA;&#x9;&#x9;internal ArrayReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source, T[] values) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[]) this.internal_request.GetValue ();&#xA;&#x9;&#x9;&#x9;T[] values_= (T[]) ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i=0; i&lt;size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static ArrayReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int,int> source, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ArrayReceiveRequest&lt;T>(internal_status, source, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A request list contains a list of outstanding MPI requests. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// The requests in a &lt;c>RequestList&lt;/c>&#xA;&#x9;/// are typically non-blocking send or receive operations (e.g.,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateReceive&amp;lt;T&amp;gt;(int, int)&quot;/>). The&#xA;&#x9;/// request list provides the ability to operate on the set of MPI requests&#xA;&#x9;/// as a whole, for example by waiting until all requests complete before&#xA;&#x9;/// returning or testing whether any of the requests have completed.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class RequestList&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Create a new, empty request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public RequestList()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.requests = new List&lt;Request>();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Add a new request to the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>The request to add.&lt;/param>&#xA;&#x9;&#x9;public void Add(Request request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Add(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Remove a request from the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>Request to remove.&lt;/param>&#xA;&#x9;&#x9;public void Remove(Request request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Remove(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieves the number of elements in this list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return this.requests.Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Waits until any request has completed. That request will then be removed &#xA;&#x9;&#x9;/// from the request list and returned.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The completed request, which has been removed from the request list.&lt;/returns>&#xA;&#x9;&#x9;public Request WaitAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = TestAny();&#xA;&#x9;&#x9;&#x9;&#x9;if (req != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines whether any request has completed. If so, that request will be removed&#xA;&#x9;&#x9;/// from the request list and returned. &#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   The first request that has completed, if any. Otherwise, returns &lt;c>null&lt;/c> to&#xA;&#x9;&#x9;///   indicate that no request has completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public Request TestAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until all of the requests has completed before returning.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>A list containing all of the completed requests.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> WaitAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;while (requests.Count > 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = WaitAny();&#xA;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Test whether all of the requests have completed. If all of the&#xA;&#x9;&#x9;/// requests have completed, the result is the list of requests. &#xA;&#x9;&#x9;/// Otherwise, the result is &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>Either the list of all completed requests, or null.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> TestAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (requests[i].Test() == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = requests;&#xA;&#x9;&#x9;&#x9;requests = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait for at least one request to complete, then return a list of&#xA;&#x9;&#x9;/// all of the requests that have completed at this point.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed, which&#xA;&#x9;&#x9;///   will contain at least one element.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> WaitSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;while (result.Count == 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Return a list of all requests that have completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed. If&#xA;&#x9;&#x9;///   no requests have completed, returns &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> TestSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = null;&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The actual list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;protected List&lt;Request> requests;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;" name="Aliencommunicator.cs" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/Aliencommunicator.dll" versionId="1.0.0.0">
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="172" x="193" y="45">
        <color b="0" g="165" r="255"/>
      </visualDescription>
    </interface>
    <interface iRef="IChannel" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* AUTOMATICALLY GENERATE CODE */&#xA;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface BaseIChannel : BaseIPeer, IBindingKind &#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIChannel.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/BaseIPeer.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;using System;&#xA;using MPI;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#xA;&#x9;public interface IChannel : BaseIChannel, IPeer, Aliencommunicator&#xA;&#x9;{&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;}" name="IChannel.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannel.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/IPeer.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using MPI;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Collections.Generic;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;/*&#xA;&#x9;public enum AliencommunicatorOperation {&#xA;&#x9;&#x9;SEND, &#xA;&#x9;&#x9;RECEIVE, &#xA;&#x9;&#x9;SEND_ARRAY,&#xA;&#x9;&#x9;RECEIVE_ARRAY,&#xA;&#x9;&#x9;PROBE,&#xA;&#x9;&#x9;ALL_GATHER,&#xA;&#x9;&#x9;ALL_GATHER_FLATTENED,&#xA;&#x9;&#x9;ALL_REDUCE,&#xA;&#x9;&#x9;ALL_REDUCE_ARRAY,&#xA;&#x9;&#x9;ALL_TO_ALL,&#xA;&#x9;&#x9;ALL_TO_ALL_FLATTENED,&#xA;&#x9;&#x9;REDUCE_SCATTER,&#xA;&#x9;&#x9;BROADCAST,&#xA;&#x9;&#x9;BROADCAST_ARRAY,&#xA;&#x9;&#x9;SCATTER,&#xA;&#x9;&#x9;SCATTER_FROM_FLATTENED,&#xA;&#x9;&#x9;GATHER,&#xA;&#x9;&#x9;GATHER_FLATTENED,&#xA;&#x9;&#x9;REDUCE,&#xA;&#x9;&#x9;REDUCE_ARRAY&#xA;&#x9;};&#xA;&#x9;*/&#xA;&#xA;&#x9;public class AliencommunicatorOperation {&#xA;&#x9;&#x9;public const int SEND = 0; &#xA;&#x9;&#x9;public const int RECEIVE = 1;&#xA;&#x9;&#x9;public const int SEND_ARRAY = 2;&#xA;&#x9;&#x9;public const int RECEIVE_ARRAY = 3;&#xA;&#x9;&#x9;public const int PROBE = 4;&#xA;&#x9;&#x9;public const int ALL_GATHER = 5;&#xA;&#x9;&#x9;public const int ALL_GATHER_FLATTENED= 6;&#xA;&#x9;&#x9;public const int ALL_REDUCE = 7;&#xA;&#x9;&#x9;public const int ALL_REDUCE_ARRAY = 8;&#xA;&#x9;&#x9;public const int ALL_TO_ALL = 9;&#xA;&#x9;&#x9;public const int ALL_TO_ALL_FLATTENED = 10;&#xA;&#x9;&#x9;public const int REDUCE_SCATTER = 11;&#xA;&#x9;&#x9;public const int BROADCAST = 12;&#xA;&#x9;&#x9;public const int BROADCAST_ARRAY = 13;&#xA;&#x9;&#x9;public const int SCATTER = 14;&#xA;&#x9;&#x9;public const int SCATTER_FROM_FLATTENED = 15;&#xA;&#x9;&#x9;public const int GATHER = 16;&#xA;&#x9;&#x9;public const int GATHER_FLATTENED = 17;&#xA;&#x9;&#x9;public const int REDUCE = 18;&#xA;&#x9;&#x9;public const int REDUCE_ARRAY = 19;&#xA;&#x9;};&#xA;&#xA;&#x9;public interface Aliencommunicator&#xA;&#x9;{&#xA;&#x9;&#x9;#region point-to-point operations&#xA;&#xA;&#x9;&#x9;// Value versions ...&#xA;&#xA;&#x9;&#x9;void Send&lt;T> (T value, Tuple&lt;int,int> dest, int tag);&#xA;&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int tag, out T outValue); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;T Receive&lt;T> (Tuple&lt;int,int> source, int tag); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int,int> source, int tag, out T value); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;Request ImmediateSend&lt;T> (T value, Tuple&lt;int,int> dest, int tag);&#xA;&#x9;&#x9;ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;// Array versions ... &#xA;&#x9;&#x9;void Send&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag);&#xA;&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;Request ImmediateSend&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag);&#xA;&#x9;&#x9;ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag, T[] values);&#xA;&#xA;&#x9;&#x9;// Probe.&#xA;&#xA;&#x9;&#x9;Status Probe (Tuple&lt;int,int> source, int tag);&#xA;&#x9;&#x9;Status ImmediateProbe (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T>(T[] inValues, int dest, int tag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T>(T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//&#x9;&#x9;void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;#endregion point-to-point operations&#xA;&#xA;&#x9;&#x9;#region collective operations&#xA;&#xA;&#x9;&#x9;#region AllToAll&#xA;&#xA;&#x9;&#x9;T[] Allgather&lt;T> (int facet, T value);&#xA;&#x9;&#x9;void Allgather&lt;T> (int facet, T inValue, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void AllgatherFlattened&lt;T> (int facet, T[] inValues, int count, ref T[] outValues);&#xA;&#x9;&#x9;void AllgatherFlattened&lt;T> (int facet, T[] inValues, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T Allreduce&lt;T>(int facet, T value, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;T[] Allreduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;void Allreduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T[] Alltoall&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;void Alltoall&lt;T> (int facet, T[] inValues, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void AlltoallFlattened&lt;T> (int facet, T[] inValues, int[] sendCounts, int[] recvCounts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;T[] ReduceScatter&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int[] counts);&#xA;&#x9;&#x9;void ReduceScatter&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region OneToAll&#xA;&#xA;&#x9;&#x9;void Broadcast&lt;T> (int facet, ref T value, int root);&#xA;&#x9;&#x9;void Broadcast&lt;T> (int facet, ref T[] values, int root);&#xA;&#xA;&#x9;&#x9;void Scatter&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;T Scatter&lt;T>(int facet, int root);&#xA;&#x9;&#x9;void Scatter&lt;T>(int facet);&#xA;&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, int[] counts, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion OneToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region AllToOne&#xA;&#xA;&#x9;&#x9;T[] Gather&lt;T> (int facet, T value, int root);&#xA;&#x9;&#x9;T[] Gather&lt;T> (int facet, int root);&#xA;&#x9;&#x9;void Gather&lt;T>(int facet);&#xA;&#x9;&#x9;void Gather&lt;T>(int facet, T inValue, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;void GatherFlattened&lt;T>(int facet, int count, ref T[] outValues);&#xA;&#x9;&#x9;T[] GatherFlattened&lt;T>(int facet, int count);&#xA;&#x9;&#x9;void GatherFlattened&lt;T> (int facet, T[] inValues, int root);&#xA;&#x9;&#x9;void GatherFlattened&lt;T>(int facet);&#xA;&#x9;&#x9;void GatherFlattened&lt;T> (int facet, int[] counts, ref T[] outValues);&#xA;&#x9;&#x9;T[] GatherFlattened&lt;T>(int facet, int[] counts);&#xA;&#xA;&#x9;&#x9;T Reduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;T[] Reduce&lt;T>(int facet, T[] values, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;void Reduce&lt;T>(int facet, T[] inValues, ReductionOperation&lt;T> op, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToOne&#xA;&#xA;&#xA;&#x9;&#x9;#endregion collective operations&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public class Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Status internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal Status(MPI.Status internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int,int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int,int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count(type);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Cancelled;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class CompletedStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.CompletedStatus internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal CompletedStatus(MPI.CompletedStatus internal_status, Tuple&lt;int,int> source) : base(internal_status, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(MPI.CompletedStatus internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new CompletedStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking communication request.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// Each request object refers to a single&#xA;&#x9;/// communication operation, such as non-blocking send &#xA;&#x9;/// (see &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>)&#xA;&#x9;/// or receive. Non-blocking operations may progress in the background, and can complete&#xA;&#x9;/// without any user intervention. However, it is crucial that outstanding communication&#xA;&#x9;/// requests be completed with a successful call to &lt;see cref=&quot;Wait&quot;/> or &lt;see cref=&quot;Test&quot;/>&#xA;&#x9;/// before the request object is lost.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class Request&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Request internal_request;&#xA;&#x9;&#x9;private Tuple&lt;int,int> source;&#xA;&#xA;&#x9;&#x9;internal Request(MPI.Request internal_request, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Wait ();&#xA;&#x9;&#x9;&#x9;return CompletedStatus.createStatus (internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Test ();&#xA;&#x9;&#x9;&#x9;return internal_status != null ? CompletedStatus.createStatus (internal_status, source) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;internal_request.Cancel ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static Request createRequest(MPI.Request internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new Request(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public abstract class ReceiveRequest : Request&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;internal ReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue ();&#xA;    }&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ValueReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#xA;&#x9;&#x9;internal ValueReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[]) this.internal_request.GetValue ();&#xA;&#x9;&#x9;&#x9;return (T) ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static ValueReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int,int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ValueReceiveRequest&lt;T>(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ArrayReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#xA;&#x9;&#x9;internal ArrayReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int,int> source, T[] values) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[]) this.internal_request.GetValue ();&#xA;&#x9;&#x9;&#x9;T[] values_= (T[]) ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i=0; i&lt;size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static ArrayReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int,int> source, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ArrayReceiveRequest&lt;T>(internal_status, source, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A request list contains a list of outstanding MPI requests. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// The requests in a &lt;c>RequestList&lt;/c>&#xA;&#x9;/// are typically non-blocking send or receive operations (e.g.,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateReceive&amp;lt;T&amp;gt;(int, int)&quot;/>). The&#xA;&#x9;/// request list provides the ability to operate on the set of MPI requests&#xA;&#x9;/// as a whole, for example by waiting until all requests complete before&#xA;&#x9;/// returning or testing whether any of the requests have completed.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class RequestList&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Create a new, empty request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public RequestList()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.requests = new List&lt;Request>();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Add a new request to the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>The request to add.&lt;/param>&#xA;&#x9;&#x9;public void Add(Request request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Add(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Remove a request from the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>Request to remove.&lt;/param>&#xA;&#x9;&#x9;public void Remove(Request request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Remove(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieves the number of elements in this list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return this.requests.Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Waits until any request has completed. That request will then be removed &#xA;&#x9;&#x9;/// from the request list and returned.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The completed request, which has been removed from the request list.&lt;/returns>&#xA;&#x9;&#x9;public Request WaitAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = TestAny();&#xA;&#x9;&#x9;&#x9;&#x9;if (req != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines whether any request has completed. If so, that request will be removed&#xA;&#x9;&#x9;/// from the request list and returned. &#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   The first request that has completed, if any. Otherwise, returns &lt;c>null&lt;/c> to&#xA;&#x9;&#x9;///   indicate that no request has completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public Request TestAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until all of the requests has completed before returning.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>A list containing all of the completed requests.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> WaitAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;while (requests.Count > 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = WaitAny();&#xA;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Test whether all of the requests have completed. If all of the&#xA;&#x9;&#x9;/// requests have completed, the result is the list of requests. &#xA;&#x9;&#x9;/// Otherwise, the result is &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>Either the list of all completed requests, or null.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> TestAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (requests[i].Test() == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = requests;&#xA;&#x9;&#x9;&#x9;requests = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait for at least one request to complete, then return a list of&#xA;&#x9;&#x9;/// all of the requests that have completed at this point.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed, which&#xA;&#x9;&#x9;///   will contain at least one element.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> WaitSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;while (result.Count == 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Return a list of all requests that have completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed. If&#xA;&#x9;&#x9;///   no requests have completed, returns &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;Request> TestSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;Request> result = null;&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Request req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = new List&lt;Request>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The actual list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;protected List&lt;Request> requests;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;" name="Aliencommunicator.cs" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/Aliencommunicator.dll" versionId="1.0.0.0">
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="179" x="227" y="489">
        <color b="144" g="238" r="144"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <unit facet="0" iRef="IChannelRoot" multiple="false" private="false" replica="0" uRef="root" visibleInterface="true">
      <super cRef="base" uRef="root"/>
      <visualDescription h="40" w="146" x="215" y="128"/>
    </unit>
    <unit facet="-1" iRef="IChannel" multiple="true" private="false" replica="0" uRef="peer" visibleInterface="true">
      <super cRef="base" uRef="peer"/>
      <visualDescription h="47" w="133" x="229" y="366"/>
    </unit>
  </componentInfo>
</component:component>